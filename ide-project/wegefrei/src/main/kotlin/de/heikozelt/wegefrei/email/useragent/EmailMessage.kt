package de.heikozelt.wegefrei.email.useragent

import de.heikozelt.wegefrei.decodeHex
import de.heikozelt.wegefrei.email.EmailAddressEntity
import java.time.ZoneId
import java.time.ZonedDateTime
import java.util.*
import javax.mail.Message
import javax.mail.Session
import javax.mail.internet.MimeBodyPart
import javax.mail.internet.MimeMultipart

/**
 * data of an email message
 * like javax.mail.Message but simplified and specific to the Wege frei! domain
 * Nutzdaten-Felder sind: from, tos, subject, coverLetter, ccs, attachments & externalID
 * Status-Felder: messageID & sentTime
 *
 * todo Sendezeitpunkt hinzufügen
 * the message id is generated by asMimeMessage() -> PrivateMimeMessage.updateMessageID() when message is sent,
 * because often the message id contains the send time stamp.
 * todo: update it here after message is sent
 *  or generate it earlier in PrivateMimeMessage and update it in asMimeMessage()
 *  or even earlier in EMailMessage constructor.
 * If sending fails generate a new message id or reuse existing one???
 * Die message id ist nur für die Protokollierung relevant.
 */
data class EmailMessage<T>(
    val externalID: T, // notice id
    val from: EmailAddressEntity,
    val tos: TreeSet<EmailAddressEntity> = TreeSet<EmailAddressEntity>(),
    val subject: String = "",
    val coverLetter: String = "",
    val ccs: TreeSet<EmailAddressEntity> = TreeSet<EmailAddressEntity>(),
    val attachments: LinkedList<EmailAttachment> = LinkedList<EmailAttachment>(),
) {
    private var mimeMsg: PrivateMimeMessage? = null

    fun getMimeMessage(): PrivateMimeMessage? {
        return mimeMsg
    }

    /**
     * Does not return a String like "<e044fd259bdb4ddb9ee9424fbc8a309965e17442@localhost>", but an ByteArray of size 20
     */
    fun getMessageID(): ByteArray? {
        val hexStr = mimeMsg?.messageID?.substring(1, 21)
        return if(hexStr == null) null else decodeHex(hexStr)
    }

    /**
     * get sent date + time but as ZonedDateTime instead of Date.
     */
    fun getSentTime(): ZonedDateTime? {
        return mimeMsg?.sentDate?.toInstant()?.atZone(ZoneId.systemDefault())
    }

    /**
     * side effect: sets sentTime
     * (but messageID is generated later on Transport.send(mimeMessage)
     */
    fun buildMimeMessage(session: Session) {
        val msg = PrivateMimeMessage(session)
        msg.addHeader("User-Agent", EmailUserAgent.MAIL_USER_AGENT)
        msg.setFrom(from.asInternetAddress())
        //msg.addHeader("Return-Receipt-To", emailMessage.from.address)
        //msg.addHeader("Disposition-Notification-To", emailMessage.from.address)
        tos.forEach { msg.addRecipient(Message.RecipientType.TO, it.asInternetAddress()) }
        ccs.forEach { msg.addRecipient(Message.RecipientType.CC, it.asInternetAddress()) }
        msg.setSubject(subject, "UTF-8")

        val multipart = MimeMultipart()
        val mainPart = MimeBodyPart()
        mainPart.setText(coverLetter, "utf-8", "html")
        multipart.addBodyPart(mainPart)

        attachments.forEach {
            multipart.addBodyPart(it.asMimeBodyPart())
        }
        msg.setContent(multipart)
        msg.sentDate = Date()
        mimeMsg = msg
    }

    /**
     * only for JUnit tests, but how to generate a mimeMessage without session???
     */
    fun sentTime(sentTime: ZonedDateTime) {
        mimeMsg?.sentDate = Date.from(sentTime.toInstant())
    }

    /**
     * only for JUnit tests, but how to generate a mimeMessage without session???
     */
    fun updateMessageID() {
        mimeMsg?.updateMessageID()
    }
}